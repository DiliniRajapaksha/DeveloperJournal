---
layout: post
comments: true
title:  "TEST DRIVEN DEVELOPMENT for Beginners"
date:   2015-11-11 13:33:41 +1100
categories: Main category
markdown_ext: "markdown, mkdown, mkdn, mkd, md"
excerpt_separator: <!--more-->
images: 
  - url: /assets/img/tdd.png
    alt: Test Driven Development illustration
    title: Test Driven Development illustration

  - url: /assets/img/tdd_hello_world_1.gif
    alt: Test Driven Development Hello world example
    title: Test Driven Development Hello world example

permalink: test-driven-development
 
---
<div class="center">
{% assign image = page.images[0] %}
{% include image.html image=image %}
</div>

## So what is TDD?

Can you actually write a test before writing a single line of implemetion logic? How do you know what method, class, or interface will contain the method under test? Sounds a bit odd...
That's exactly how I felt when I first read about TDD. 
<!--more-->

> Test-driven development (TDD) is a software development process that relies on the repetition of a very short development cycle: requirements are turned into very specific test cases, then the software is improved to pass the new tests, only. 
>
>--- [Test-driven development. (2016, November 20). In Wikipedia, The Free Encyclopedia. Retrieved 23:45, November 20, 2016](https://en.wikipedia.org/w/index.php?title=Test-driven_development&oldid=750634597)

But once I got the hang of it I realised, that's the whole point! It guides you through the design.

TDD concept was introduced or developed by Kent Beck and in his book Test Driven Development: By Example he explains the pains of traditional development process and how adopting test driven development helps. And also the foundation and key concepts are explained with lots of code samples.

<hr>

## LETS TEST THE WATERS WITH A HELLO WORLD

<hr> 

All that is great! But how do you really apply TDD in ‘real word’ Java development?
Well, I started by applying it to a ‘hello world’. Too trivial, I know, but I like it to be as simple as possible.

##### 1 | Writting the test

<div>
{% assign image = page.images[1] %}
{% include image.html image=image %}
</div>

##### 2 | Writting the minimum code in order to pass the test

<div>
{% assign image = page.images[1] %}
{% include image.html image=image %}
</div>

##### 3 | Refactor the test and the code

<div>
{% assign image = page.images[1] %}
{% include image.html image=image %}
</div>

<hr>

## TOOLS, TECHNOLOGIES, FRAMEWORKS, AND JARGON

<hr> 

It's that simple. So what's keeping you from practicing TDD? So let's get started. 

##### In order to follow TDD we must be good at few things:

- Writting great unit tests
    + We'll discuss JUnit in this post
- Mocking
    + There are a few mocking frameworks out there. We'll discuss Mockito, PowerMockito, and DBUnit in a future post.
- TDD mindset
    + For this I suggest reading "Test Driven Development: By Example" by Kent Beck.

##### Some jargon
- **Class under test** - The class which contains the method that the unit test would be testing.
- **Method under test** - The target method a unit test is executing (testing). There should be no more that one method under test for a single unit test method.
- **Test fixture** - a test fixture is data that is required to execute a test. eg: an object setup in a certain state. A single test fixture could be used in serveral test methods.


<hr>

## JUNIT4 BASICS

<hr> 

##### Basic annotations in JUnit4

~~~
    public class SampleTest {

        @BeforeClass
        public static void setUpBeforeClass() throws Exception {
            
            
            //Method annotated with `@BeforeClass` will execute once before any of the test methods in this class.

            //This method could be used to set up any test fixtures that are computationally expensive and shared by several test methods. eg:establishing database connections 

            //Sometimes several tests need to share computationally expensive setup (like logging into a database). While this can compromise the independence of tests, sometimes it is a necessary optimization. From http://junit.sourceforge.net/javadoc/org/junit/BeforeClass.html
           
        }

        @AfterClass
        public static void tearDownAfterClass() throws Exception {
            
            //Method annotated with `@AfterClass` will execute once after all of the test methods are executed in this class.

            //If you allocate expensive external resources in a BeforeClass method you need to release them after all the tests in the class have run. Annotating a public static void method with @AfterClass causes that method to be run after all the tests in the class have been run. All @AfterClass methods are guaranteed to run even if a BeforeClass method throws an exception. From http://junit.sourceforge.net/javadoc/org/junit/AfterClass.html
        }

        @Before
        public void setUp() throws Exception {
             //Method annotated with `@Before` will execute before each test method in this class is executed.

             //If you find that several tests need similar objects created before they can run this method could be used to do set up those objects (aka test-fixtures).
        }
        
        @After
        public void tearDown() throws Exception {
             
             //Method annotated with `@After` will execute after each test method in this class is executed.

             //If you allocate external resources in a Before method you must release them in this method.
        }

        @Test
        public void test1() {
           
           //A public void method annotated with @Test will be executed as a test case.
        }

        @Test
        public void test2() {
   
            //Another test cases
        }

    }
~~~
{: .language-java}

- `@Before` and `@After` sandwitches **each test method** in the class.
- `@BeforeClass` and `@AfterClass` sandwitches **all of the test methods** in a JUnit test class.
-  So when you run the above JUnit test class, the execution order is:
    1. Method annotated with `@BeforeClass`
    2. Method annotated with `@Before`
    3. First method annotated with `@Test` i.e. `test1()`.
    4. Method annotated with `@After`    
    5. Method annotated with `@Before`
    6. Second method annotated with `@Test` i.e. `test2()`.
    7. Method annotated with `@After`
    8. Method annotated with `@AfterClass`
